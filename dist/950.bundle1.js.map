{"version":3,"file":"950.bundle1.js","mappings":"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","sources":["webpack://tokenization/./node_modules/thirdweb/dist/esm/utils/domains.js","webpack://tokenization/./node_modules/thirdweb/dist/esm/version.js","webpack://tokenization/./node_modules/thirdweb/dist/esm/utils/process.js","webpack://tokenization/./node_modules/thirdweb/dist/esm/utils/fetch.js","webpack://tokenization/./node_modules/thirdweb/dist/esm/storage/upload/web-node.js"],"sourcesContent":["export const DEFAULT_RPC_URL = \"rpc.thirdweb.com\";\nconst DEFAULT_SOCIAL_URL = \"social.thirdweb.com\";\nconst DEFAULT_IN_APP_WALLET_URL = \"embedded-wallet.thirdweb.com\";\nconst DEFAULT_PAY_URL = \"pay.thirdweb.com\";\nconst DEFAULT_STORAGE_URL = \"storage.thirdweb.com\";\nconst DEFAULT_BUNDLER_URL = \"bundler.thirdweb.com\";\nconst DEFAULT_ANALYTICS_URL = \"c.thirdweb.com\";\nlet domains = {\n    rpc: DEFAULT_RPC_URL,\n    inAppWallet: DEFAULT_IN_APP_WALLET_URL,\n    social: DEFAULT_SOCIAL_URL,\n    pay: DEFAULT_PAY_URL,\n    storage: DEFAULT_STORAGE_URL,\n    bundler: DEFAULT_BUNDLER_URL,\n    analytics: DEFAULT_ANALYTICS_URL,\n};\n/**\n * @internal\n */\nexport const setThirdwebDomains = (DomainOverrides) => {\n    domains = {\n        rpc: DomainOverrides.rpc ?? DEFAULT_RPC_URL,\n        inAppWallet: DomainOverrides.inAppWallet ?? DEFAULT_IN_APP_WALLET_URL,\n        social: DomainOverrides.social ?? DEFAULT_SOCIAL_URL,\n        pay: DomainOverrides.pay ?? DEFAULT_PAY_URL,\n        storage: DomainOverrides.storage ?? DEFAULT_STORAGE_URL,\n        bundler: DomainOverrides.bundler ?? DEFAULT_BUNDLER_URL,\n        analytics: DomainOverrides.analytics ?? DEFAULT_ANALYTICS_URL,\n    };\n};\n/**\n * @internal\n */\nexport const getThirdwebDomains = () => {\n    return domains;\n};\n/**\n * @internal\n */\nexport const getThirdwebBaseUrl = (service) => {\n    const origin = domains[service];\n    if (origin.startsWith(\"localhost\")) {\n        return `http://${origin}`;\n    }\n    return `https://${origin}`;\n};\n//# sourceMappingURL=domains.js.map","export const version = \"5.80.0\";\n//# sourceMappingURL=version.js.map","export const IS_DEV = \n// biome-ignore lint/nursery/noProcessEnv: ok in this file\nprocess.env.NODE_ENV === \"development\" || process.env.NODE_ENV === \"test\";\n//# sourceMappingURL=process.js.map","import { version } from \"../version.js\";\nimport { LruMap } from \"./caching/lru.js\";\nimport { detectOS, detectPlatform, } from \"./detect-platform.js\";\nimport { isJWT } from \"./jwt/is-jwt.js\";\nimport { IS_DEV } from \"./process.js\";\nconst DEFAULT_REQUEST_TIMEOUT = 60000;\n/**\n * @internal\n */\nexport function getClientFetch(client, ecosystem) {\n    /**\n     * @internal\n     */\n    async function fetchWithHeaders(url, init) {\n        const { requestTimeoutMs = DEFAULT_REQUEST_TIMEOUT, ...restInit } = init || {};\n        let headers = restInit.headers ? new Headers(restInit.headers) : undefined;\n        // check if we are making a request to a thirdweb service (we don't want to send any headers to non-thirdweb services)\n        if (isThirdwebUrl(url)) {\n            if (!headers) {\n                headers = new Headers();\n            }\n            // auth token if secret key === jwt\n            const authToken = client.secretKey && isJWT(client.secretKey)\n                ? client.secretKey\n                : undefined;\n            // secret key if secret key !== jwt\n            const secretKey = client.secretKey && !isJWT(client.secretKey)\n                ? client.secretKey\n                : undefined;\n            const clientId = client.clientId;\n            // if we have an auth token set, use that (thirdweb dashboard sets this for the user)\n            // pay urls should never send the auth token, because we always want the \"developer\" to be the one making the request, not the \"end user\"\n            if (authToken &&\n                !isPayUrl(url) &&\n                !isInAppWalletUrl(url) &&\n                !isBundlerUrl(url)) {\n                headers.set(\"authorization\", `Bearer ${authToken}`);\n            }\n            else if (secretKey) {\n                headers.set(\"x-secret-key\", secretKey);\n            }\n            else if (clientId) {\n                headers.set(\"x-client-id\", clientId);\n            }\n            if (ecosystem) {\n                headers.set(\"x-ecosystem-id\", ecosystem.id);\n                if (ecosystem.partnerId) {\n                    headers.set(\"x-ecosystem-partner-id\", ecosystem.partnerId);\n                }\n            }\n            // this already internally caches\n            for (const [key, value] of getPlatformHeaders()) {\n                headers.set(key, value);\n            }\n        }\n        let controller;\n        let abortTimeout;\n        if (requestTimeoutMs) {\n            controller = new AbortController();\n            abortTimeout = setTimeout(() => {\n                controller?.abort(\"timeout\");\n            }, requestTimeoutMs);\n        }\n        return fetch(url, {\n            ...restInit,\n            headers,\n            signal: controller?.signal,\n        }).finally(() => {\n            if (abortTimeout) {\n                clearTimeout(abortTimeout);\n            }\n        });\n    }\n    return fetchWithHeaders;\n}\n// NOTE: these all start with \".\" because we want to make sure we don't match (for example) \"otherthirdweb.com\"\nconst THIRDWEB_DOMAINS = [\n    \".thirdweb.com\",\n    \".ipfscdn.io\",\n    // dev domains\n    \".thirdweb.dev\",\n    \".thirdweb-dev.com\",\n];\nexport const IS_THIRDWEB_URL_CACHE = new LruMap(4096);\n/**\n * @internal\n */\nexport function isThirdwebUrl(url) {\n    if (IS_THIRDWEB_URL_CACHE.has(url)) {\n        // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n        return IS_THIRDWEB_URL_CACHE.get(url);\n    }\n    try {\n        const { hostname } = new URL(url);\n        try {\n            // special case for localhost in development only\n            if (IS_DEV) {\n                if (hostname === \"localhost\") {\n                    IS_THIRDWEB_URL_CACHE.set(url, true);\n                    return true;\n                }\n            }\n        }\n        catch { }\n        const is = THIRDWEB_DOMAINS.some((domain) => hostname.endsWith(domain));\n        IS_THIRDWEB_URL_CACHE.set(url, is);\n        return is;\n    }\n    catch {\n        IS_THIRDWEB_URL_CACHE.set(url, false);\n        return false;\n    }\n}\nfunction isPayUrl(url) {\n    try {\n        const { hostname } = new URL(url);\n        // pay service hostname always starts with \"pay.\"\n        return hostname.startsWith(\"pay.\");\n    }\n    catch {\n        return false;\n    }\n}\nfunction isInAppWalletUrl(url) {\n    try {\n        const { hostname } = new URL(url);\n        // in app wallet service hostname always starts with \"in-app-wallet.\" or \"embedded-wallet.\"\n        return (hostname.startsWith(\"in-app-wallet.\") ||\n            hostname.startsWith(\"embedded-wallet.\"));\n    }\n    catch {\n        return false;\n    }\n}\nfunction isBundlerUrl(url) {\n    try {\n        const { hostname } = new URL(url);\n        return (hostname.endsWith(\".bundler.thirdweb.com\") ||\n            hostname.endsWith(\".bundler.thirdweb-dev.com\"));\n    }\n    catch {\n        return false;\n    }\n}\nconst SDK_NAME = \"unified-sdk\";\nlet previousPlatform;\n/**\n * @internal\n */\nexport function getPlatformHeaders() {\n    if (previousPlatform) {\n        return previousPlatform;\n    }\n    let os = null;\n    if (typeof navigator !== \"undefined\") {\n        os = detectOS(navigator.userAgent);\n    }\n    let bundleId = undefined;\n    if (typeof globalThis !== \"undefined\" && \"Application\" in globalThis) {\n        // shims use wallet connect RN module which injects Application info in globalThis\n        // biome-ignore lint/suspicious/noExplicitAny: get around globalThis typing\n        bundleId = globalThis.Application.applicationId;\n    }\n    previousPlatform = Object.entries({\n        \"x-sdk-platform\": detectPlatform(),\n        \"x-sdk-version\": version,\n        \"x-sdk-os\": os ? parseOs(os) : \"unknown\",\n        \"x-sdk-name\": SDK_NAME,\n        ...(bundleId ? { \"x-bundle-id\": bundleId } : {}),\n    });\n    return previousPlatform;\n}\n/**\n * @internal\n */\nfunction parseOs(os) {\n    const osLowerCased = os.toLowerCase();\n    if (osLowerCased.startsWith(\"win\")) {\n        return \"win\";\n    }\n    // we do NOT use the lowercase here\n    switch (os) {\n        case \"Mac OS\":\n            return \"mac\";\n        case \"iOS\":\n            return \"ios\";\n        case \"Android OS\":\n            return \"android\";\n        default:\n            // if we somehow fall through here, just replace all spaces with underscores and send it\n            return osLowerCased.replace(/\\s/gi, \"_\");\n    }\n}\n//# sourceMappingURL=fetch.js.map","import { getThirdwebDomains } from \"../../utils/domains.js\";\nimport { getClientFetch } from \"../../utils/fetch.js\";\nexport async function uploadBatch(client, form, fileNames, options) {\n    const headers = {};\n    const res = await getClientFetch(client)(`https://${getThirdwebDomains().storage}/ipfs/upload`, {\n        method: \"POST\",\n        headers,\n        body: form,\n    });\n    if (!res.ok) {\n        res.body?.cancel();\n        if (res.status === 401) {\n            throw new Error(\"Unauthorized - You don't have permission to use this service.\");\n        }\n        if (res.status === 402) {\n            throw new Error(\"You have reached your storage limit. Please add a valid payment method to continue using the service.\");\n        }\n        if (res.status === 403) {\n            throw new Error(\"Forbidden - You don't have permission to use this service.\");\n        }\n        throw new Error(`Failed to upload files to IPFS - ${res.status} - ${res.statusText}`);\n    }\n    const body = await res.json();\n    const cid = body.IpfsHash;\n    if (!cid) {\n        throw new Error(\"Failed to upload files to IPFS - Bad CID\");\n    }\n    if (options?.uploadWithoutDirectory) {\n        return [`ipfs://${cid}`];\n    }\n    return fileNames.map((name) => `ipfs://${cid}/${name}`);\n}\n//# sourceMappingURL=web-node.js.map"],"names":["domains","rpc","inAppWallet","social","pay","storage","bundler","analytics","getThirdwebDomains","version","IS_DEV","DEFAULT_REQUEST_TIMEOUT","THIRDWEB_DOMAINS","IS_THIRDWEB_URL_CACHE","SDK_NAME","previousPlatform","parseOs","os","osLowerCased","toLowerCase","startsWith","replace","async","uploadBatch","client","form","fileNames","options","res","ecosystem","url","init","requestTimeoutMs","restInit","controller","abortTimeout","headers","Headers","undefined","has","get","hostname","URL","set","is","some","domain","endsWith","isThirdwebUrl","authToken","secretKey","clientId","isPayUrl","isInAppWalletUrl","isBundlerUrl","id","partnerId","key","value","bundleId","navigator","userAgent","globalThis","Application","applicationId","Object","entries","getPlatformHeaders","AbortController","setTimeout","abort","fetch","signal","finally","clearTimeout","getClientFetch","method","body","ok","cancel","status","Error","statusText","cid","json","IpfsHash","uploadWithoutDirectory","map","name"],"sourceRoot":""}