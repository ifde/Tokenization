import { create } from 'ipfs-http-client';


const ipfs = await create({
    host: 'localhost',
    port: 5001,
    protocol: 'http'
  });

async function uploadToIPFS(data) {
    const result = await ipfs.add(JSON.stringify(data));
    console.log("IPFS Hash:", result.path); // Use this hash in the smart contract
}


// import { create } from 'ipfs-http-client';

// const ipfs = create({ host: 'ipfs.infura.io', port: 5001, protocol: 'https' });

//async function uploadToIPFS(data) {
//    const result = await ipfs.add(JSON.stringify(data));
//    console.log("IPFS Hash:", result.path); // Use this hash in the smart contract
//}

const fitnessData = {
    session_id: "RUN_20240101_001",
    user_id: "USER_001",
    start_time: "2024-01-01T18:00:00Z",
    end_time: "2024-01-01T18:45:00Z",
    summary: {
        total_distance: 5920,
        duration_seconds: 2700,
        average_pace: 7.36,
        average_heart_rate: 142,
        total_calories: 385,
        elevation_gain: 64
    }
};

uploadToIPFS(fitnessData);

async function getDataFromIPFS(ipfsHash) {
    try {

        // Fetch the data stream from IPFS
        const stream = ipfs.cat(ipfsHash);

        const chunks = [];
        for await (const chunk of stream) {
            chunks.push(chunk); // Collect all chunks
        }

        // Combine chunks into a single buffer
        const buffer = Buffer.concat(chunks);

        // Convert buffer to a string
        const rawData = buffer.toString('utf-8'); // Decodes the ASCII values into a string

        // Parse the JSON data
        const jsonData = JSON.parse(rawData);
        console.log("Parsed JSON data:", jsonData);
    } catch (error) {
        console.error("Ошибка при получении данных с IPFS:", error);
    }
}

// Пример использования IPFS хеша, полученного из смарт-контракта
const ipfsHash = "QmUhh3ECXF2cfEkUg4nxxCphb6q3ttKJQ5XZu7KmTawNXm"; // Пример хеша
getDataFromIPFS(ipfsHash);


// ipfs daemon - start an ipfs server so that you can take your node online and interact with the IPFS network
// CTRL + C - Stop the daemon
// ps aux | grep ipfs - to find running deamons
// kill 12345 - to kill the process of a running daemon 


// brew install node
// This installs Node.js - a runtime environment for running Java Script code on MacOS
// Plus it installs npm - a Node Package Manager

// Yarn and npm create yarn.lock and package-lock.json correspondingly when you initialize them.
// Also, package.json is created which contains information about the current project plus dependencies. 
// Both yarn and npm access this file
// Then, each package (like hardhat) has its configuration file (like hardhat.config.ts or tsconfig.js)


// package.json - to determine dependencies of the project 
// package-lock.json - for NPM to determine what packages to intall ona where to install them from 
// yarn.lock - same for YARN package manager 

// Using hardhat guide 
// npm install -g yarn
// git init
// yarn init -y - adds Node Modules

//yarn installs dependencies from package.json.
//yarn init creates a package.json for a new project.


// yarn add -D hardhat. HardHat is an Ethereum development package for professionals. -D stands for DevDependencies
// It facilitates interacting with a smart contract.
// Actually, this command adds a DevDEPENDENCY plus installs it in node_modules.
// (A folder which contains all the packages needed to run the project)
// npx hardhat (this adds node_modules folder in order to execute hardhat package locally in this folder) - Node Package Execute. 
// This command allows you to execute Node.js packages directly from the npm registry 


// npx hardhat compile: Compiles your smart contracts.
// npx hardhat test: Runs tests for your smart contracts.
// npx hardhat run: Executes a JavaScript or TypeScript script within your Hardhat environment. For example, running deployment scripts.
// npx hardhat node: Starts a local Ethereum network to test your contracts.

// without globally installing them on your system
// For this to work, set "type": "commonjs" in package.json
// npx hardhat compile - compiles a project 

// Some useful packages
// yarn add -D @nomiclabs/hardhat-ethers ethers @nomicfoundation/hardhat-chai-matchers ethereum-waffle chai

// yarn add -D ts-node typescript

// yarn add -D chai @types/node @types/mocha @types/chai

// npx hardhat node - Start a local node
// CTRL + C - terminate this node

// Put your .sol file into the "contracts" folder (generated by the compiler). 
// Then, create "scripts" folder and put deploy.js file there(you will write it by yourself)

// npx hardhat run scripts/deploy.ts --network localhost. Deploy the script

// RPC (Remote Procedure Call) - a software communication protocol that one program uses to request a service f
// rom another program located on a different server

// BNB Smart Chain (Build and Build) - a chain for deployment of DApps. No assosiation with Binance. 
// Also refferd to as BSC.

// Ethereum Virtual Machine (EVM) - executes smart contracts on different chains, including BNB chain

// BNB Faucet - a place where you can get tBNB tokens (for testnet)

// npm install dotenv - a package for writing secure information

// A gateway is a server that acts as an intermediary between a client and a decentralized storage network. 
// It allows users to access and retrieve data stored on the network.

// yarn add thirdweb - Addting thirdweb package (this is a service to upload data to ipfs)

// guide on how to use thirdweb - https://portal.thirdweb.com/typescript/v5/getting-started

// npx hardhat run scripts/deploy.js --network bscTestnet
// Deploying a contract on the web 

// npm install ethers@^5.7.2 --force
// Installing a workable version of ethers


// A port  is a register that can receive and send data from other ports. 
// Servers that listen to the port can work with data from it and also send data to the port.
// When deployed, our contract is attached to a wallet (Metamask)
// When we use a faucet and send some money to the wallet, we tell the wallet to listen to the port at faucet's url. 
// When calling a contract function from our code, we send a request to the port - in our case, faucet 
// Then the contract gets the request, proccesses it and sends some data back through the port. 
// Basically, it's all done under the hood in hardhat package. 

// The server (Ethereum node) listens on a specific port (e.g., 8545) for incoming requests.
// When a client (e.g., your app) wants to interact with the Ethereum network, 
// it makes RPC calls to the server via the appropriate port.


// First, create a new local node using 
// npx hardhat node
// Next, compile a contract 
// npx hardhat compile 
// Third, deploy a contract locally 
// npx hardhat run scripts/ContractDeploy.ts --network localhost
// paste contract address into api.mjs (it updates each time you deploy a contract)

// Choose any account from the local node and paste its secret key into hardhat.config.ts 
// AND into a variable in api.mjs inside Wallet() function
// Note: it makes this account the signer of operations for this contract.

// Question: why would we put a secret wallet key into hardhat.config.ts if deployment happens without it?

// Okay, I got it! 
// Answer: deployment costs gas and so we want to hardhat.config.ts to know where to take it from 

// In api.mjs, we create a new object to work with this contract and use a different signer for operations. 
// (In this case, they're the same)

// Changes:
// Deploy on the ETH testnet 
// add show_all() and delete() functions to the contract 
// Launch the API on the website 
// Commit to git and push to GitHub
// Switch from using .mjs files 
// Use data from contract (address & abi) automatically in api.mjs or better so, find a way not to use them

// TypeScript and JavaScript scripts / modules
// Scripts are simple files with code executed in the global scope.
// Modules are files with code that runs in their own scope, 
// and they use import and export to share functionality between files.

// Node.js - a runtime invironment that allows you to run JavaScript code on the server instead of a browser.

/*
CommonJS (CJS)
A module system used in Node.js before ES Modules.
Uses require and module.exports.
Default for Node.js projects unless "type": "module" is set in package.json.
Hardhat in CJS

ES (ECMAScript) Module (ESM)
(ECMAScript - the standard specification for JavaScript)
The modern JavaScript module system.
Uses import and export.
Required for frontend apps and modern tooling.
Enabled in Node.js by setting "type": "module" or using .mjs.

ESM Project
A project where "type": "module" is set in package.json.
.js files are treated as ESM by default.
Requires all dependencies to work with import/export.

.json
A data format, often used for configuration (package.json).
Can be imported in both CJS and ESM, but behaves slightly differently 
(e.g., sometimes requires --experimental-json-modules in ESM).

.js
JavaScript file.
Treated as CJS or ESM depending on the "type" field in package.json.

.ts
TypeScript file.
Needs to be compiled to .js before running.
Can be used with either CJS or ESM depending on project configuration.
*/


/*
var: Function-scoped, can be re-declared, and is hoisted. Avoid using it due to potential bugs.
let: Block-scoped, cannot be re-declared in the same scope, and is safer for mutable variables.
const: Block-scoped, cannot be re-assigned after initialization, used for constants.
*/

// yarn add web3
